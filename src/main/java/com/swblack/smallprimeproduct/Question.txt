문제]
인수로 2, 3, 5, 7만을 가지는 숫자들을 '작은 소수들의 곱셈'이라고 정의하자. 이런 '작은 소수들의 곱셈'에는 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 24, 25, 27 등이 있다.
N번째 '작은 소수들의 곱셈'을 알아내는 프로그램을 작성하자.




[입력]
첫 번째 줄에 테스트 케이스의 개수 T가 주어진다. 이어서 T개의 테스트 케이스가 주어지는데 각 테스트 케이스는 한줄로 구성이 된다.
테스트 케이스의 첫 번째 줄에 N이 주어진다. (1 ≤ N ≤ 5842)




[출력]
각각의 테스트 케이스에 대하여 #x(x는 테스트 케이스 번호를 의미)를 출력하고 공백을 하나 둔 다음 N번째 '작은 소수들의 곱셈'을 출력한다.




[입출력 예]
(입력)
5
1
11
100
1000
5842




(출력)
#1 1
#2 12
#3 450
#4 385875
#5 2000000000






http://m.blog.naver.com/programmer18/220684940941

제가 요즘 읽고있는 "코딩 인터뷰 완전분석 (Cracking the Coding Interview)" 라는 책이 있는데 이 책에서 이 문제랑 비슷한 문제에 대해서 설명했는데, 이 책에 나온 문제는

"3,5,7의 세 소수만을 약수로 갖는 N 번째 수를 찾는 알고리즘을 설계하라"

였어요. 굉장히 비슷하죠? 단지 다른점은 우리는 임의의 K개의 소수가 주어지지만 책에서 소개한 문제에서는 3,5,7이라는 소수만을 생각하면 됩니다. 책에서는 다음과 같은 알고리즘을 소개합니다:

1. array와 큐 Q3,Q5,Q7 초기화
2. 1을 array에 삽입
3. 1*3,1*5,1*7을 각각 Q3,Q5,Q7에 삽입.
4. x를 Q3,Q5,Q7의 최솟값으로 설정.
5. x가 어느 큐에서 발견되느냐에 따라 다음을 수행:
Q3: 3*x, 5*x, 7*x를 각각 Q3,Q5,Q7에 삽입. x를 Q3에서 제거.
Q5: 5*x,7*x를 각각 Q5,Q7에 삽입. x를 Q5에서 제거.
Q7: 7*x를 Q7에 삽입. x를 Q7에서 제거.
6. N번째를 찾을때까지 4~6반복.

이 알고리즘을 약간만 변형하면 이 문제의 답을 얻을 수 있습니다. Q3,Q5,Q7만 선언하지 않고 우리는 아예 array of queues (큐로 된 배열)을 사용해서 위와 같은 알고리즘을 실행할 수 있습니다. 저는 다음과 같이 구현해봤어요:
